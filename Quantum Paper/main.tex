\documentclass{amsart}
\usepackage{amsmath,coffeestains,float} 
\usepackage{hyperref}
\DeclareMathAlphabet{\pazocal}{OMS}{zplm}{m}{n}
\newcommand{\X}{\mathcal{X}}% Required for inserting images
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\ta}{\theta}
\title{Non-Abelian Hidden Subgroup Problem}
\author{Gabriel Arteaga, Jeremy Bruce }
\begin{document}
\begin{abstract}
In this paper we discuss The Hidden Subgroup Problem and various implementations of the problem using quantum methods. We distinguish solving HSP over abelian and non ablien groups, with some abelian groups having already existing quantum algorithms, which is not true for non abelian. However, there is an important fundamental result that proves a quantum algorithm exists for all finite groups, that make polylogarithmic calls to the oracle. Last, we look at a specific instance of HSP, over the nonabelian Dihedral group and specific solution of HSP for this group. 
\end{abstract}

\maketitle


\section{Introduction} 
%Talk about what HSP is
Given a group $G$ and a subgroup $H$ of $G$ and a finite set $X$, a function $f:G\rightarrow X$ hides the subgroup if 
\[\forall g_1,g_2,\in G, f(g_1)=f(g_2) \iff g_1H=g_2H\]
The Hidden subgroup problem states that, with this group $G$ and the finite set $X$, given a hiding function from an oracle we want to find a generating set for $H$ based on evaluations of $f$. Classically algorithms aren't much more efficient than brute force, thus quantum is an obvious step forward in looking for solutions. Unfortunately, or fortunately for group theorists, group structure varies wildly, in this paper in specific we will be looking at the Non-Abelian HSP. We call a group $G$ abelian if, 
\[\forall g_1,g_2 \in G, g_1g_2=g_2g_1\]
Thus a group is Non-Abelian if this condition does not hold. In solving the abelian HSP, we have pre-existing general methods no matter what. This is all balanced on the theorem that states that for any finite abelian group is isomorphic to to a direct sum of cyclic groups,
\[G\cong \Z_{u1}\oplus \Z_{u2}\oplus \Z_{u3}\oplus\dots\oplus\Z_{un}\]
We can then apply QFT into this decomposition and proceed into algorithms like Shor's Factoring Algorithm. However this theorem does not exist in any form for Non-Abelian groups. Thus we be creative. 

\section{A Brief Review of Rep. Theory}
A representation is a homomorphism from the group to the general linear group, $GL(V)$, where $V$ is any finite vector space over $\C$. Thus for any $g\in G$, the representation, $\rho(g)$ is an, $n\times n$ matrix. 
\subsection{Irreducibility}
The main feature of these representations we will use is the irreducibility. We first say that an invariant subspace, is a $W\subseteq V$ such that 
\[\rho(g)W\subseteq W, \forall g \in G\]
then $W$ is invariant under the representation. If there are no non-zero invariant proper subspaces of $V$ then there the representation is said to be irreducible. With this definition we now discuss the parallel to the decomposition of abelian groups. We say that a group representation is decomposable if there is a non-zero $V_1\subset V$ such that $V_1$ is invariant, then we may always find another non-zero invariant $V_2\subset V$ such that $V=V_1\oplus V_2$. We can restrict each representation $p$ to the vector space $V_i$ and call it $\rho_i$, thus we can decompose any representation into 
\[\rho=\rho_1\oplus\rho_2.\]
Repeating this process we can achieve the irreducible form of $\rho$, that is
\[\rho=\rho_1\oplus \dots \oplus \rho_n\]
where each $\rho_i$ is irreducible, this is our parallel to the abelian decomposition. 
\subsection{Characters}
We now briefly discuss characters of representations. Each representation has a character called, 
\[\X_\rho=tr(\rho(g)).\]
Which is the trace of the representation. 

\section{Simple Case of HSP}

A simple case of solving HSP, is finding the periodicity of the function over a cyclic group, which are inherently abelian groups. For cyclic groups, finding the period is equivalent to finding the subgroup, since the subgroup is generated by the period. To this we follow a simple algorithm laid out in Maria Schuld's article of period finding, of encoding the function into the quantum state $\sum_{x}|x\rangle|f(x)\rangle$, applying the QFT onto the first register, and measure. Schuld implements this algorithm over a cyclic group of 16 elements $\{0,1,..,15\}$ \cite{periodfinding-2025}. 

\href{https://colab.research.google.com/drive/1n-2i-I35nJf5ZCOjhs3KQeiVX5ZgpPqi?usp=sharing}{Link to Colab Notebook}This group requires only 4 qubits to represent the each input, and we use a predefined function $f(x) = x \mod 8$, that has period 8 for testing. Schuld starts by converting the integers and the function outputs into computational basis states. She also manually creates the unitary oracle for the predefined function, by implementing it as a 128 x 128 unitary matrix. The circuit itself is rather simple, prepare the inital state using haddamard and the oracle, apply QFT, and then measure the 4 input qubits. Here is a snapshot of the circuit:  
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Unknown.png}
    \caption{Quantum Period Finding Circuit}
    \label{fig:placeholder}
\end{figure}

The QFT transforms the spatial periodicity into frequency peaks and the measured output k is a multiple of the frequency N/r, where N is the length of the group, r is the periodicity. Through classical methods, specifically reducing the fraction k/N and taking the LCM of the resulting denominators, the hidden period r is successfully recovered. Here is snapshot of the code use to compute these calculations: 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Screenshot 2025-12-18 at 3.14.55 PM.png}
    \caption{Finding period using LCM}
    \label{fig:placeholder}
\end{figure}
\section{Query Complexity}
https://arxiv.org/abs/quant-ph/0401083
Using the Quantum Fourier Transform to solve HSP works well for abelian groups, as irreducible representations of abelian groups are one dimensional, and using such representation to create a generator of the group is proven to be efficient classically. However, the QFT is not always guaranteed, especially for the non-abelian case, since the aforementioned properties are not true for those groups. 

An important result proven by Ettinger, Høyer, and Knill (EHK) in their paper "The quantum query complexity of the hidden subgroup problem is polynomial", is that given a finite group \textit{G} promised to have hidden subgroup \textit{H}, and an oracle \textit{f} over \textit{G}, there exists a quantum algorithm that makes a polynomial number of oracle calls in \(log|G|\), obtaining enough information to determine \textit{H}. This algorithm succeeds with probability at least \(1 - 4r/2^{s/2}\)\cite{querycomplexity-2004}.

Before beginning the algorithm, some pre-processing must be done. Given a group \textit{G}, with \textit{r} distinct subgroups, enumerate each subgroup, and arrange them in the form $K_1, K_2, ... K_r$, where $|K_i| \geq |K_{i+1}|$ for $i = 1,2,...,r$. Since each generator can have at most $n = log|G|$ elements, the number of generators, and therefore the number of distinct subgroups, of any group \textit{G} is $2^{O(n^2)}$ \cite{querycomplexity-2004}. Therefore, using classical algorithms for the pre-processing of this quantum algorithm, would take exponential time. However, the main consequence of this algorithm, is showing that the quantum part of solving HSP, by preparing coset states and applying subgroup tests, requires only polylogarithimic time and queries.

The algorithm described by EHK requires $2 + s$ quantum registers, where \textit{s} is a positive integer chosen to ensure low error probability. The first register will contain an integer $\nu$, corresponding to a subgroup index, between 0 and \textit{r}. The second register is a counter \textit{l} that is incremented after the hidden subgroup if found, and also takes integers between 0 and \textit{r}. Therefore, the first two registers require log r qubits each. The remaining s registers are grouped in pairs, where each register holds an element \textit{g }of \textit{G} and also $f(g)$.

The algorithm begins by creating an initial state
\[|\Psi_{init}\rangle = |0\rangle|0\rangle \otimes (\frac{1}{\sqrt{N}}\sum_{g \in G} |g\rangle|f(g)\rangle)^{\otimes s}\] for $N = |G|$. A function \textit{f} is $K_\mu$ periodic, ie $K_\mu$ a hidden subgroup of G, if the \textit{s} subgroup registers are in a superposition of coset states $|tK_\mu\rangle = \frac{1}{\sqrt{|K_\mu|}}\sum_{k \in K_\mu}|tk\rangle$, where $t \in T$ for some left translation \textit{T} of $K_\mu$. EHK then defines an operator \textbf{Test} that tests for the hidden subgroup among the \textit{r} possible subgroups \cite{querycomplexity-2004}. \textbf{Test} is defined as 
\[\textbf{Test} = Test_r \dotsi Test_2\cdot Test_1\]
where each $Test_\mu$ is a unitary operator that tests whether f is $K_\mu$ periodic. This \textbf{Test} is applied to the initial state $|\Psi_{init}\rangle$, such that each $Test_\mu$ is applied to the initial state sequentially, testing for each subgroup once. When f is $K_\mu$ periodic $Test_\mu$ stores $\mu$ in the first register and increments \textit{l} in the second register. Periodicity is checked by seeing if the s subgroup registers are in superpositions of coset states for $K_\mu$. Therefore, if f is $K_\mu$ periodic, then 
\[Test_\mu|\Psi_{init}\rangle = |\mu\rangle|1\rangle \otimes(\frac{1}{\sqrt{N}}\sum_{g \in G} |g\rangle|f(g)\rangle)^{\otimes s} = |\mu\rangle|1\rangle \otimes (\frac{1}{\sqrt{|K_\mu|}}\sum_{t \in K_\mu}|tK_\mu\rangle|f(t)\rangle)^{\otimes s}\]
After applying \textbf{Test} we can take a measurement of the final state $|\Psi_{final}\rangle$ to obtain the index $\mu$ of the hidden subgroup. Since the generator corresponding to that index was already computed from pre-processing, we are able to output a generating set \cite{querycomplexity-2004}.

If $f$ is not $K_\mu$ periodic, then the distance $|(Test_\mu|\Psi_{init}\rangle) -|\Psi_{init}\rangle|$ is at most $\frac{2}{2^{s/2}}$. This distance is sequentially doubled on multiple failed tests, so the distance between the initial and the state $|\Psi_{\nu-1}\rangle$ is at most $\frac{2r}{2^{s/2}}$. This puts the probability of failing $Test_\nu$ at most $\frac{4r}{2^{s/2}}$ and the probability of being the hidden subgroup at $1 - \frac{4r}{2^{s/2}}$\cite{querycomplexity-2004}. In their paper EHK also mentions an exact algorithm with zero error, by using amplitude amplification to remove error probability. This algorithm keeps the polylogarithimic query calls, but also requires even more complicated computations. But, the existence of such an algorithm definitively proves the lower bounds of the query complexity for any finite group. 


\section{Dihedral Group Solutions}
We begin this section by recalling the basic definition of the Dihedral group. For some $N\geq 3$, 
\[D_n=\langle x,y |x^n=y^2=yxyx=1\rangle\].
This group represents all of the possible symmetries of a n-gon. This group splits into two major subgroups, one of rotations and one of reflections. These are, 
\[H_{rot}=\{1,x,x^2,\dots,x^{n-1}\}\]
and 
\[H_{ref}=\{y,yx,yx^2,\dots,yx^{n-1}\}\]
This second subgroup is where we will focus our attention to, as the first subgroup as shown in \cite{kuperberg-2003}, can easily be reduced to using Shor's Factoring Algorithm. Thus we denote $H=\langle xy^s\rangle$, where s is called the slope or shift of the reflection. In order to find this kind of hidden subgroup it is clear that the approach of Ettinger-Hoyer-Knull works very poorly. Thus, we must create a new algorithm to find this hidden subgroup, this is the approach of Kuperberg. We will first state the following proposition. 
\\
Proposition 2.1: Finding an arbitrary hidden subgroup $H$ of $D_n$ reduces to finding the slope of a hidden reflection. 
We refer to \cite{kuperberg-2003} for the proof of this proposition, and begin to explore his algorithm. \\
There are two approaches that Kuperberg took, one in $2003$, and one in $2011$, the latter is still currently the fastest algorithm that we have for the Dihedral case of non-Abelian HSP. 
\subsection*{Kuperberg 2003}
We begin the $2003$ approach by dilating our hiding function, $f:G\rightarrow$, into a unitary
\[U_f:\C[G]\rightarrow \C[G]\otimes \C[S]=\C[G\times S]\]
This computes the standard basis as 
\[U_f|g\rangle=|g,f(g)\rangle\]
We begin by computing the unitary over all elements of $G$, then discard the output register and leave the input register for the rest of our computations. This leaves us with the mixed state 
\[\rho_{G/ H}=\frac{1}{|G|}\sum_{a\in G} |Ha\rangle\langle Ha|\]
on the input register. We now specify G as the dihedral group. Each element of the dihedral may be represented, with $t \in \Z/ N, s\in \Z/ 2$, as
\[g=y^tx^s\]
Thus in the input register, now $\C[D_n]$, we have $n$ qubits for $s$ and $1$ qubit to for $t$. We now wish to apply a character transform to $\rho_{D_N/ H}$, which represents itself as the following unitary transform,
\[F_n:|s\rangle \rightarrow \frac{1}{\sqrt{N}}exp\left(\frac{2\pi i k s}{N}\right)|k\rangle .\]
We then measure $k$, the label for our coset, and are left with the following qubit, this state corresponds to the 2 dimensional irreducible representation of the projected coset of $D_N$ labeled by $k$ and has encoded $s$ into our phase,
\[|\psi_k\rangle \propto |0\rangle+exp\left(\frac{2\pi i k s}{N}\right)|1\rangle  .\]
We use proportionality to omit the normalization. We can create one of these for each coset of $D_N$ so we suppose that we hae $2^{O(\sqrt{n})}$ states $|\psi_k\rangle$, each having it's own determined yet random value of $k$. We aim to create the state
\[|\psi_{2^{n-1}}\rangle \propto |0\rangle +(-1)^s|1\rangle.\]
This clearly gives us the parity of s. The way of creating this state is what gives Kuperberg his speedup we aim to compute $s$ by way of reducing bits to 0 as we only need the last few bits to calculate the slope. Thus we begin with the sieve, you begin with two states $|\psi_k\rangle$ and $|\psi_l\rangle$, and create their joint state
\[|\psi_k\rangle \otimes |\psi_l\rangle\propto |0,0\rangle +exp\left(\frac{2\pi i k s}{N}\right)|1,0\rangle+exp\left(\frac{2\pi i k l}{N}\right)|0,1\rangle+exp\left(\frac{2\pi i (k+l)}{N}\right)|1,1\rangle\]. 
We then apply a CNOT gate and measure the right qubit. What we are left with is the qubit with residual state,

\[|\psi_{k\pm l}\rangle \propto |0\rangle+exp\left(\frac{2\pi i (k+l)}{N}\right)|1\rangle\].
There is a probability $\frac{1}{2}$ that the label of the extracted qubit,$k+\ell$, will have $\sqrt{n}$ more trailing zeros than either the $k$ or $\ell$ label. We repeat this for all state pairs, form it into a new set of coset states and repeat the sieve until all we have left are states, $|\psi_0\rangle$ and $|\psi_{2n-1}\rangle$. We then measure any of the states $|\psi_{2n-1}\rangle$ in order to determine the parity of $s$ thus giving us a single bit of $s$, thus completing the sieve.\\
\subsection*{Kuperberg 2011}
We now discuss Kuperbergs $2011$ approach, which abandons the representations in favor of a more direct approach, that of collimation. We start with a hidden shift problem, where $f,g:\Z_n\rightarrow X$ are injective functions, such that $f(x)=g(x+s),\, \forall x\in X$, where $s$ is our hidden shift. To reduce this into a hidden subgroup problem we define a third function which is equivalent to our hiding function. We call it $h:D_N\rightarrow X$ given by
\begin{equation*}
    h(x):=\left\{
    \begin{aligned}
        &f(x) \text{ if } (0,x)\\
        &g(x) \text{ if } (1,x)\\
    \end{aligned}
    \right.
\end{equation*}
What this function gives us other than being equivalent to our hiding function is that the first value, $b$, marks if it is an element of the rotation subset with $0$ and $1$ if it is an element of the reflection subset. We extend this function as a unitary and apply it to the superposition of coset states, 
\[\frac{1}{\sqrt{2N}}\sum_{b\in\{0,1\}}\sum_{x\in\Z_N}|b,x\rangle|0\rangle\rightarrow\frac{1}{\sqrt{2N}}\sum_{b\in\{0,1\}}\sum_{x\in\Z_N}|b,x\rangle|h(b,x)\rangle\]
We then measure the second register leaving us with $\ell$ many states,
\[|0\rangle+\exp\left(\frac{2\pi i b s}{N}\right)\]
These states contain information about the shift $s$ and the label $b$. As $b$ is $0$ or $1$ if it is an element of the rotation subset we are left with $|0\rangle+|1\rangle$ so we collect no shift information from these states. Thus we Fourier Sample these $\ell$ states creating what Kuperberg called phase states, 
\[|\psi\rangle \propto \sum_{0\leq j\leq\ell}\exp\left(\frac{2\pi i b(j)s}{N}\right)|j\rangle \]
Note that $b(j)$ is the Fourier mode, which is stored classically, it indexes states by their low-ordered bits $\mod(2^m)$ and we use this to find a list of $r$ states that have similar phases. Once we have this list of $r$ vectors we take the tensor product, 
\[|\psi_{j_1}\rangle\otimes\dots\otimes|\psi_{j_r}\rangle\]
Then measure the labels $\mod(2^m)$ in order to get our collimated label, $c=(b(j_1)+\dots+b_r(j_r))\mod(2^m)$, and the projection of the measurement is our new phase state that will have more trailing zero's in the low-bits than our previous un-collimated states called $P_c|\psi\rangle$. This state is what contains our bit of $s$ we are attempting to extract. There is some shifting of the indexing as the bare indexing set makes re-running collimation a nightmare, we just choose a bijection,$\pi$, that maps each new state to a convenient label whose indexing set has the same cardinality of the original. We turn this bijection into a unitary and then apply it to get our new phase state, 
\[|\psi_{\text{new}}\rangle=U_{\pi}P_c|\psi\rangle\]
After this both the $2003$ and the $2011$ algorithms return to the same point, we repeat either the sieve or the collimation with $s\mod(N/2)$ and continue to do so until we recover all bits of $s$. With all bits of $s$ we simply calculate, 
\[H=\{(0,0),(1,s)\}\]
 It is important to state how we know how many bits $s$ has. $N=2^n$ thus $s\in \Z_{2^n}$, thus we know that the upper bound on number of bits that $s$ may have is $\log_2(N)$ bits.
 
 
 
 
 
 
 
 
 
 With both approaches we end up having to iterate $O(\sqrt{\log(N)})$ times, however the difference in the updated version of Kuperberg's algorithm is the space complexity. The original algorithm had equal space and time complexity, $\exp(O(\sqrt{\log(N)}))$, with this updated version we can now reduce this down to $O(\log(N))$ qubits, and using $\exp\left(O\left(\sqrt{\log(N)}\right)\right)$ classical space. 


\bibliographystyle{plain}
\bibliography{sources}
\end{document}
